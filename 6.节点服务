此外,ROS 为更加直接的一对一通信提供了一种称为服务(services)的机制。
	第二种通信机制更为少见,但是也有其应用价值.

	服务（services）是节点之间通讯的另一种方式。
	服务允许节点发送请求（request） 并获得一个响应（response）。
	rosservice可以很轻松的使用 ROS 客户端/服务器框架提供的服务。
	rosservice提供了很多可以在topic上使用的命令。
	
	使用方法:
	列出所有服务，
		rosservice list         输出可用服务的信息
		可以获取目前活跃的所有服务.
		rosservice list 命令的输出是所有服务的全局名称。

		rosservice call         调用带参数的服务
		rosservice type         输出服务类型
		rosservice find         依据类型寻找服务find services by service type
		rosservice uri          输出服务的ROSRPC uri

	服务调用(service calls)。服务调用与消息的区别主要体现在两个方面。
	1 服务调用是双向的,一个节点给另一个节点发送信息并等待
	  响应,因此信息流是双向的。作为对比,当消息发布后,并
	  没有响应的概念,甚至不能保证系统内有节点订阅了这些消息。

	2 服务调用实现的是一对一通信。每一个服务由一个节点发起,
	  对这个服务的响应返回同一个节点。另一方面,每一个消息
	  都和一个话题相关,这个话题可能有很多的发布者和订阅者。

	客户端(client)节点发送一些称为请求(request)
	的数据到一个服务器(server)节点,并且等待回应。
	服务器节点接收到请求后,采取一些行动(计算、配置软件或硬件、改变
	自身行为等),然后发送一些称为响应(response)的数据给客户端节点。

	[client] ------> request-------->[server]--------->response------->[client]
	客户端         发送请求           服务端            响应              客户端
	请求和响应数据携带的特定内容由服务数据类型(servicedata type)来决定,
	它与决定消息内容的消息类型是类似的

	同消息类型一样,服务数据类型也是由一系列域构成的。
	唯一的区别就在于服务数据类型分为两部分,分别表示
	请求  (客户端节点提供给服务器节点)和
	响应  (服务其节点反馈给客户端节点)。

	服务的类型
	1) 特定节点的服务。一些服务,例如上表中 
	  get_loggers 和 set_logger_level（roscore节点提供）
	  是关于节点日志消息的服务,是用来从特定的节点获取或者向其传递信息的。
	  这类服务通常将节点名用作命名空间来防止命名冲突,
	  并且允许节点通过 私 有 名 称 来 提 供 服 务 , 
	  例 如 ~get_loggers 或 者~set_logger_level 
	  (参照 4.5 了解 loggers 和 logger level 的详情)。
	  
	2) 通用节点服务。其他服务表示更一般的不针对某些特定节点的服务。
	  例如,名 为 /spawn 的 服 务 用 于 生 成 一 个 新 的 仿 真 海 龟 , 是 由
	  turtlesim 节点提供的。但是在不同的系统中,这个服务完全可能由其他节点提供;
	  当我们调用/spawn 时,我们只关心是
	  否有一个新的海龟出现,而不关心具体哪个节点起作用这种细 节 。 
	  上 表 列 出 的 所 有 服 务 , 除 了 get_loggers 和
	  set_logger_level,都可以归入此类。这类服务都有特定的名称来描述
	  它们的功能,却不会涉及任何特定节点。


